extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.6", import: ["@extends", "@external", "@key", "@shareable"])

interface BaseError {
  message: String
}

type BibleBook {
  id: ID!
  name(languageId: ID, primary: Boolean): [BibleBookName!]!
  osisId: String!
  alternateName: String
  paratextAbbreviation: String!
  isNewTestament: Boolean!
  order: Int!
}

type BibleBookName {
  value: String!
  primary: Boolean!
  language: Language!
}

type BibleCitation {
  id: ID!
  osisId: String!
  bibleBook: BibleBook!
  chapterStart: Int!
  chapterEnd: Int
  verseStart: Int!
  verseEnd: Int
  video: Video!
}

type CloudflareImage {
  id: ID!
  uploadUrl: String
  userId: ID!
  createdAt: Date!
  aspectRatio: ImageAspectRatio
  url: String
  mobileCinematicHigh: String
  mobileCinematicLow: String
  mobileCinematicVeryLow: String
  thumbnail: String
  videoStill: String
}

type CloudflareR2 {
  id: ID!
  fileName: String!
  uploadUrl: String
  userId: ID!
  publicUrl: String
  createdAt: Date!
  updatedAt: Date!
}

input CloudflareR2CreateInput {
  id: String
  fileName: String!
  videoId: String!
}

input CloudflareR2UpdateInput {
  id: String!
  fileName: String!
}

type CloudflareVideo {
  id: ID!
  uploadUrl: String
  userId: ID!
  createdAt: Date!
  readyToStream: Boolean!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

type Error implements BaseError
  @shareable
{
  message: String
}

type ForeignKeyConstraintError implements BaseError
  @shareable
{
  message: String

  """The arguments that caused the foriegn key constraint violation"""
  location: [ForeignKeyConstraintErrorLocation!]
}

type ForeignKeyConstraintErrorLocation {
  """An array describing the path in the arguments that caused this error"""
  path: [String!]

  """The value that was provided at the path"""
  value: String
}

enum IdType {
  databaseId
  slug
}

enum ImageAspectRatio {
  hd
  banner
}

input ImageInput {
  aspectRatio: ImageAspectRatio
  videoId: ID
}

type Keyword {
  id: ID!
  value: String!
  language: Language!
}

type Language
  @key(fields: "id")
  @extends
{
  id: ID! @external
  seriesCount: Int!
  featureFilmCount: Int!
  shortFilmCount: Int!
}

type LanguageWithSlug {
  language: Language!
  slug: String!
}

enum MediaRole {
  publisher
}

type Mutation {
  createCloudflareUploadByFile(input: ImageInput): CloudflareImage!
  createCloudflareUploadByUrl(url: String!, input: ImageInput): CloudflareImage!
  createCloudflareImageFromPrompt(prompt: String!, input: ImageInput): CloudflareImage!
  deleteCloudflareImage(id: ID!): Boolean!
  cloudflareUploadComplete(id: ID!): Boolean!
  cloudflareR2Create(input: CloudflareR2CreateInput!): CloudflareR2!
  cloudflareR2Update(input: CloudflareR2UpdateInput!): CloudflareR2!
  cloudflareR2Delete(id: ID!): CloudflareR2!
  createCloudflareVideoUploadByFile(uploadLength: Int!, name: String!): CloudflareVideo!
  createCloudflareVideoUploadByUrl(url: String!): CloudflareVideo!
  deleteCloudflareVideo(id: ID!): Boolean!
  createImageBySegmindPrompt(prompt: String!, model: SegmindModel!): CloudflareImage! @deprecated(reason: "use createCloudflareImageFromPrompt")
  triggerUnsplashDownload(url: String!): Boolean!
  createMuxVideoUploadByFile(name: String!): MuxVideo!
  createMuxVideoUploadByUrl(url: String!): MuxVideo!
  deleteMuxVideo(id: ID!): Boolean!

  """
  Create a new short link domain that can be used for short links (this domain must have a CNAME record pointing to the short link service)
  """
  shortLinkDomainCreate(input: MutationShortLinkDomainCreateInput!): MutationShortLinkDomainCreateResult!

  """Update services that can use this short link domain"""
  shortLinkDomainUpdate(input: MutationShortLinkDomainUpdateInput!): MutationShortLinkDomainUpdateResult!

  """
  delete an existing short link domain (all related short links must be deleted first)
  """
  shortLinkDomainDelete(id: String!): MutationShortLinkDomainDeleteResult!

  """create a new short link"""
  shortLinkCreate(input: MutationShortLinkCreateInput!): MutationShortLinkCreateResult!

  """update an existing short link"""
  shortLinkUpdate(input: MutationShortLinkUpdateInput!): MutationShortLinkUpdateResult!

  """delete an existing short link"""
  shortLinkDelete(id: String!): MutationShortLinkDeleteResult!
  videoCreate(input: VideoCreateInput!): Video!
  videoUpdate(input: VideoUpdateInput!): Video!
  videoDescriptionCreate(input: VideoTranslationCreateInput!): VideoDescription!
  videoDescriptionUpdate(input: VideoTranslationUpdateInput!): VideoDescription!
  videoDescriptionDelete(id: ID!): VideoDescription!
  videoImageAltCreate(input: VideoTranslationCreateInput!): VideoImageAlt!
  videoImageAltUpdate(input: VideoTranslationUpdateInput!): VideoImageAlt!
  videoImageAltDelete(id: ID!): VideoImageAlt!
  videoSnippetCreate(input: VideoTranslationCreateInput!): VideoSnippet!
  videoSnippetUpdate(input: VideoTranslationUpdateInput!): VideoSnippet!
  videoSnippetDelete(id: ID!): VideoSnippet!
  videoStudyQuestionCreate(input: VideoStudyQuestionCreateInput!): VideoStudyQuestion!
  videoStudyQuestionUpdate(input: VideoStudyQuestionUpdateInput!): VideoStudyQuestion!
  videoStudyQuestionDelete(id: ID!): VideoStudyQuestion!
  videoSubtitleCreate(input: VideoSubtitleCreateInput!): VideoSubtitle!
  videoSubtitleUpdate(input: VideoSubtitleUpdateInput!): VideoSubtitle!
  videoSubtitleDelete(id: ID!): VideoSubtitle!
  videoTitleCreate(input: VideoTranslationCreateInput!): VideoTitle!
  videoTitleUpdate(input: VideoTranslationUpdateInput!): VideoTitle!
  videoTitleDelete(id: ID!): VideoTitle!
  videoEditionCreate(input: VideoEditionCreateInput!): VideoEdition!
  videoEditionUpdate(input: VideoEditionUpdateInput!): VideoEdition!
  videoEditionDelete(id: ID!): VideoEdition!
  videoVariantCreate(input: VideoVariantCreateInput!): VideoVariant!
  videoVariantUpdate(input: VideoVariantUpdateInput!): VideoVariant!
  videoVariantDelete(id: ID!): VideoVariant!
  videoVariantDownloadCreate(input: VideoVariantDownloadCreateInput!): VideoVariantDownload!
  videoVariantDownloadUpdate(input: VideoVariantDownloadUpdateInput!): VideoVariantDownload!
  videoVariantDownloadDelete(id: ID!): VideoVariantDownload!
}

input MutationShortLinkCreateInput {
  """
  short link path not including the leading slash (defaults to a random 11 character string that is URL friendly)
  """
  pathname: String

  """
  the fully qualified domain name (FQDN) to redirect the short link service should redirect the user to
  """
  to: String!

  """
  the fully qualified domain name (FQDN) to redirect the short link service should redirect the user to
  """
  hostname: String!

  """the service that created this short link"""
  service: Service!
}

union MutationShortLinkCreateResult = ZodError | NotUniqueError | MutationShortLinkCreateSuccess

type MutationShortLinkCreateSuccess {
  data: ShortLink!
}

union MutationShortLinkDeleteResult = NotFoundError | MutationShortLinkDeleteSuccess

type MutationShortLinkDeleteSuccess {
  data: ShortLink!
}

input MutationShortLinkDomainCreateInput {
  """the hostname including subdomain, domain, and TLD, but excluding port"""
  hostname: String!

  """
  the services that are enabled for this domain, if empty then this domain can be used by all services
  """
  services: [Service!]
}

union MutationShortLinkDomainCreateResult = NotUniqueError | MutationShortLinkDomainCreateSuccess

type MutationShortLinkDomainCreateSuccess {
  data: ShortLinkDomain!
}

union MutationShortLinkDomainDeleteResult = NotFoundError | ForeignKeyConstraintError | MutationShortLinkDomainDeleteSuccess

type MutationShortLinkDomainDeleteSuccess {
  data: ShortLinkDomain!
}

input MutationShortLinkDomainUpdateInput {
  id: String!

  """
  the services that are enabled for this domain, if empty then this domain can be used by all services
  """
  services: [Service!]!
}

union MutationShortLinkDomainUpdateResult = NotFoundError | MutationShortLinkDomainUpdateSuccess

type MutationShortLinkDomainUpdateSuccess {
  data: ShortLinkDomain!
}

input MutationShortLinkUpdateInput {
  id: String!

  """
  the fully qualified domain name (FQDN) to redirect the short link service should redirect the user to
  """
  to: String!
}

union MutationShortLinkUpdateResult = ZodError | NotFoundError | MutationShortLinkUpdateSuccess

type MutationShortLinkUpdateSuccess {
  data: ShortLink!
}

type MuxVideo {
  id: ID!
  uploadUrl: String
  userId: ID!
  createdAt: Date!
  readyToStream: Boolean!
}

type NotFoundError implements BaseError
  @shareable
{
  message: String

  """The arguments that caused the not found error"""
  location: [NotFoundErrorLocation!]
}

type NotFoundErrorLocation {
  """An array describing the path in the arguments that caused this error"""
  path: [String!]

  """The value that was provided at the path"""
  value: String
}

type NotUniqueError implements BaseError
  @shareable
{
  message: String

  """The arguments that caused the uniqueness violation"""
  location: [NotUniqueErrorLocation!]
}

type NotUniqueErrorLocation {
  """An array describing the path in the arguments that caused this error"""
  path: [String!]

  """The value that was provided at the path"""
  value: String
}

type Query {
  getMyCloudflareImages(offset: Int, limit: Int): [CloudflareImage!]!
  getMyCloudflareImage(id: ID!): CloudflareImage!
  getMyCloudflareVideos(offset: Int, limit: Int): [CloudflareVideo!]!
  getMyCloudflareVideo(id: ID!): CloudflareVideo!
  listUnsplashCollectionPhotos(collectionId: String!, page: Int, perPage: Int, orientation: UnsplashPhotoOrientation): [UnsplashPhoto!]!
  searchUnsplashPhotos(query: String!, page: Int, perPage: Int, orderBy: UnsplashOrderBy, collections: [String!], contentFilter: UnsplashContentFilter, color: UnsplashColor, orientation: UnsplashPhotoOrientation): UnsplashQueryResponse!
  bibleBooks: [BibleBook!]!
  bibleCitations: [BibleCitation!]!
  keywords: [Keyword!]!
  getMyMuxVideos(offset: Int, limit: Int): [MuxVideo!]!
  getMyMuxVideo(id: ID!): MuxVideo!

  """List of short link domains that can be used for short links"""
  shortLinkDomains(
    """Filter by service (including domains with no services set)"""
    service: Service
  ): [ShortLinkDomain!]!

  """Find a short link domain by id"""
  shortLinkDomain(id: String!): QueryShortLinkDomainResult!

  """find a short link by path and hostname"""
  shortLinkByPath(
    """short link path not including the leading slash"""
    pathname: String!

    """the hostname including subdomain, domain, and TLD, but excluding port"""
    hostname: String!
  ): QueryShortLinkByPathResult!

  """find a short link by id"""
  shortLink(id: String!): QueryShortLinkResult!

  """find all short links with optional hostname filter"""
  shortLinks(
    """the hostname including subdomain, domain, and TLD, but excluding port"""
    hostname: String
  ): [ShortLink!]!
  adminVideo(id: ID!, idType: IdType = databaseId): Video!
  adminVideos(where: VideosFilter, offset: Int, limit: Int): [Video!]!
  adminVideosCount(where: VideosFilter): Int!
  video(id: ID!, idType: IdType = databaseId): Video!
  videos(where: VideosFilter, offset: Int, limit: Int): [Video!]!
  videosCount(where: VideosFilter): Int!
  videoEditions: [VideoEdition!]!
  videoEdition(id: ID!): VideoEdition
  videoVariants: [VideoVariant!]!
  tags: [Tag!]!
  taxonomies(category: String, languageCodes: [String!]): [Taxonomy!]!
}

union QueryShortLinkByPathResult = NotFoundError | QueryShortLinkByPathSuccess

type QueryShortLinkByPathSuccess {
  data: ShortLink!
}

union QueryShortLinkDomainResult = NotFoundError | QueryShortLinkDomainSuccess

type QueryShortLinkDomainSuccess {
  data: ShortLinkDomain!
}

union QueryShortLinkResult = NotFoundError | QueryShortLinkSuccess

type QueryShortLinkSuccess {
  data: ShortLink!
}

enum SegmindModel {
  sdxl1__0_txt2img
  kandinsky2__2_txt2img
  sd1__5_paragon
  tinysd1__5_txt2img
}

enum Service {
  apiJourneys
  apiLanguages
  apiMedia
  apiTags
  apiUsers
  apiVideos
}

"""A short link that redirects to a full URL"""
type ShortLink
  @key(fields: "id")
{
  id: ID!

  """short link path not including the leading slash"""
  pathname: String!

  """
  the fully qualified domain name (FQDN) to redirect the short link service should redirect the user to
  """
  to: String!
  domain: ShortLinkDomain!

  """the service that created this short link"""
  service: Service!
}

"""A domain that can be used for short links"""
type ShortLinkDomain {
  id: ID!
  hostname: String!
  createdAt: Date!
  updatedAt: Date!

  """
  The services that are enabled for this domain, if empty then this domain can be used by all services
  """
  services: [Service!]!
}

type Tag
  @key(fields: "id")
{
  id: ID!
  parentId: ID
  name(languageId: ID, primary: Boolean): [TagName!]!
  service: Service
}

type TagName {
  id: ID!
  value: String!
  primary: Boolean!
  language: Language!
}

type Taxonomy {
  id: ID!
  category: String!
  term: String!
  name(languageCodes: [String!], category: String): [TaxonomyName!]!
}

type TaxonomyName {
  id: ID!
  term: String!
  label: String!
  language: Language!
  taxonomy: Taxonomy!
}

enum UnsplashColor {
  black_and_white
  black
  white
  yellow
  orange
  red
  purple
  magenta
  green
  teal
  blue
}

enum UnsplashContentFilter {
  low
  high
}

enum UnsplashOrderBy {
  latest
  relevant
  editorial
}

type UnsplashPhoto {
  id: ID!
  created_at: String!
  updated_at: String
  blur_hash: String
  width: Int!
  height: Int!
  color: String
  description: String
  alt_description: String
  promoted_at: String
  likes: Int!
  urls: UnsplashPhotoUrls!
  links: UnsplashPhotoLinks!
  user: UnsplashUser!
}

type UnsplashPhotoLinks {
  self: String!
  html: String!
  download: String!
  download_location: String!
}

enum UnsplashPhotoOrientation {
  landscape
  portrait
  squarish
}

type UnsplashPhotoUrls {
  full: String!
  raw: String!
  regular: String!
  small: String!
  thumb: String!
}

type UnsplashQueryResponse {
  total: Int!
  total_pages: Int!
  results: [UnsplashPhoto!]!
}

type UnsplashUser {
  id: ID!
  updated_at: String!
  username: String!
  name: String!
  first_name: String!
  last_name: String
  twitter_username: String
  portfolio_url: String
  bio: String
  location: String
  instagram_username: String
  total_collections: Int!
  total_likes: Int!
  total_photos: Int!
  links: UnsplashUserLinks!
  profile_image: UnsplashUserImage!
}

type UnsplashUserImage {
  small: String!
  medium: String!
  large: String!
}

type UnsplashUserLinks {
  followers: String!
  following: String!
  html: String!
  likes: String!
  photos: String!
  portfolio: String!
  self: String!
}

type User
  @key(fields: "id")
  @extends
{
  id: ID! @external
  mediaUserRoles: [MediaRole!]!
}

type Video
  @key(fields: "id primaryLanguageId")
  @shareable
{
  bibleCitations: [BibleCitation!]!
  keywords(languageId: ID): [Keyword!]!
  id: ID!
  label: VideoLabel!
  primaryLanguageId: ID!
  published: Boolean!
  cloudflareAssets: [CloudflareR2!]!
  title(languageId: ID, primary: Boolean): [VideoTitle!]!
  snippet(languageId: ID, primary: Boolean): [VideoSnippet!]!
  description(languageId: ID, primary: Boolean): [VideoDescription!]!
  studyQuestions(languageId: ID, primary: Boolean): [VideoStudyQuestion!]!
  image: String @deprecated(reason: "use images.mobileCinematicHigh")
  imageAlt(languageId: ID, primary: Boolean): [VideoImageAlt!]!
  videoStill: String @deprecated(reason: "use images.videoStill")
  thumbnail: String @deprecated(reason: "use images.thumbnail")
  mobileCinematicHigh: String @deprecated(reason: "use images.mobileCinematicHigh")
  mobileCinematicLow: String @deprecated(reason: "use images.mobileCinematicLow")
  mobileCinematicVeryLow: String @deprecated(reason: "use images.mobileCinematicVeryLow")
  variantLanguages: [Language!]!
  variantLanguagesCount: Int!

  """slug is a permanent link to the video."""
  slug: String!
  noIndex: Boolean
  children: [Video!]!

  """the number value of the amount of children on a video"""
  childrenCount: Int!
  parents: [Video!]!
  variantLanguagesWithSlug: [LanguageWithSlug!]!
  variants: [VideoVariant!]!
  subtitles(languageId: ID, primary: Boolean, edition: String): [VideoSubtitle!]!
  variant(languageId: ID): VideoVariant
  images(aspectRatio: ImageAspectRatio): [CloudflareImage!]!
}

input VideoCreateInput {
  id: String!
  label: VideoLabel!
  primaryLanguageId: String!
  published: Boolean!
  slug: String!
  noIndex: Boolean!
  childIds: [String!]!
}

type VideoDescription {
  id: ID!
  value: String!
  primary: Boolean!
  language: Language!
}

type VideoEdition {
  id: ID!
  name: String
  videoVariants: [VideoVariant!]!
  videoSubtitles: [VideoSubtitle!]!
}

input VideoEditionCreateInput {
  id: ID!
  name: String
}

input VideoEditionUpdateInput {
  id: ID!
  name: String
}

type VideoImageAlt {
  id: ID!
  value: String!
  primary: Boolean!
  language: Language!
}

enum VideoLabel {
  collection
  episode
  featureFilm
  segment
  series
  shortFilm
  trailer
  behindTheScenes
}

type VideoSnippet {
  id: ID!
  value: String!
  primary: Boolean!
  language: Language!
}

type VideoStudyQuestion {
  id: ID!
  value: String!
  primary: Boolean!
  language: Language!
}

input VideoStudyQuestionCreateInput {
  id: ID
  videoId: String!
  value: String!
  primary: Boolean!
  languageId: String!
  crowdInId: String

  """index from 1"""
  order: Int!
}

input VideoStudyQuestionUpdateInput {
  id: ID!
  value: String
  primary: Boolean
  crowdInId: String

  """index from 1"""
  order: Int
}

type VideoSubtitle {
  id: ID!
  languageId: ID!
  primary: Boolean!
  edition: String!
  vttSrc: String
  srtSrc: String
  value: String!
  language: Language!
  videoEdition: VideoEdition!
}

input VideoSubtitleCreateInput {
  id: ID
  videoId: String!
  edition: String!
  vttSrc: String
  srtSrc: String
  primary: Boolean!
  languageId: String!
}

input VideoSubtitleUpdateInput {
  id: ID!
  edition: String!
  vttSrc: String
  srtSrc: String
  primary: Boolean
  languageId: String
}

type VideoTitle {
  id: ID!
  value: String!
  primary: Boolean!
  language: Language!
}

input VideoTranslationCreateInput {
  id: ID
  videoId: String!
  value: String!
  primary: Boolean!
  languageId: String!
}

input VideoTranslationUpdateInput {
  id: ID!
  value: String
  primary: Boolean
  languageId: String
}

input VideoUpdateInput {
  id: String!
  label: VideoLabel
  primaryLanguageId: String
  published: Boolean
  slug: String
  noIndex: Boolean
  childIds: [String!]
}

type VideoVariant {
  id: ID!
  hls: String
  dash: String
  share: String
  downloadable: Boolean!
  downloads: [VideoVariantDownload!]!
  duration: Int!
  language: Language!
  videoEdition: VideoEdition!
  subtitle(languageId: ID, primary: Boolean): [VideoSubtitle!]!
  subtitleCount: Int!

  """slug is a permanent link to the video variant."""
  slug: String!
}

input VideoVariantCreateInput {
  id: String!
  videoId: String!
  edition: String!
  hls: String
  dash: String
  share: String
  duration: Int
  languageId: String!
  slug: String!
  downloadable: Boolean!
}

type VideoVariantDownload {
  id: ID!
  quality: VideoVariantDownloadQuality!
  size: Float!
  height: Int!
  width: Int!
  url: String!
}

input VideoVariantDownloadCreateInput {
  id: String
  videoVariantId: String!
  quality: VideoVariantDownloadQuality!
  size: Float
  height: Int
  width: Int
  url: String!
}

enum VideoVariantDownloadQuality {
  low
  high
}

input VideoVariantDownloadUpdateInput {
  id: String!
  videoVariantId: String
  quality: VideoVariantDownloadQuality
  size: Float
  height: Int
  width: Int
  url: String
}

input VideoVariantUpdateInput {
  id: String!
  videoId: String
  edition: String
  hls: String
  dash: String
  share: String
  duration: Int
  languageId: String
  slug: String
  downloadable: Boolean
}

input VideosFilter {
  availableVariantLanguageIds: [ID!]
  title: String
  labels: [VideoLabel!]
  ids: [ID!]
  subtitleLanguageIds: [ID!]
}

type ZodError implements BaseError
  @shareable
{
  message: String
  fieldErrors: [ZodFieldError!]
}

type ZodFieldError {
  message: String
  path: [String!]
}