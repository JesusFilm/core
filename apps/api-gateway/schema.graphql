schema
  @core(feature: "https://specs.apollo.dev/core/v0.1"),
  @core(feature: "https://specs.apollo.dev/join/v0.1")
{
  query: Query
  mutation: Mutation
}

directive @core(feature: String!) repeatable on SCHEMA

directive @join__field(graph: join__Graph, requires: join__FieldSet, provides: join__FieldSet) on FIELD_DEFINITION

directive @join__type(graph: join__Graph!, key: join__FieldSet) repeatable on OBJECT | INTERFACE

directive @join__owner(graph: join__Graph!) on OBJECT | INTERFACE

directive @join__graph(name: String!, url: String!) on ENUM_VALUE

interface Action {
  gtmEventName: String
}

interface Block {
  id: ID!
  parentBlockId: ID
}

type ButtonBlock implements Block {
  action: Action
  color: ButtonColor
  endIcon: Icon
  id: ID!
  label: String!
  parentBlockId: ID
  size: ButtonSize
  startIcon: Icon
  variant: ButtonVariant
}

enum ButtonColor {
  error
  inherit
  primary
  secondary
}

enum ButtonSize {
  large
  medium
  small
}

enum ButtonVariant {
  contained
  text
}

type CardBlock implements Block {
  """backgroundColor should be a HEX color value e.g #FFFFFF for white."""
  backgroundColor: String

  """
  coverBlockId is present if a child block should be used as a cover.
  This child block should not be rendered normally, instead it should be used
  as a background. Blocks are often of type ImageBlock or VideoBlock.
  """
  coverBlockId: ID

  """
  fullscreen should control how the coverBlock is displayed. When fullscreen
  is set to true the coverBlock Image should be displayed as a blur in the
  background.
  """
  fullscreen: Boolean!
  id: ID!
  parentBlockId: ID

  """
  themeMode can override journey themeMode. If nothing is set then use
  themeMode from journey
  """
  themeMode: ThemeMode

  """
  themeName can override journey themeName. If nothing is set then use
  themeName from journey
  """
  themeName: ThemeName
}

input CardBlockCreateInput {
  backgroundColor: String
  coverBlockId: ID
  fullscreen: Boolean
  id: ID
  journeyId: ID!
  parentBlockId: ID
  themeMode: ThemeMode
  themeName: ThemeName
}

input CardBlockUpdateInput {
  backgroundColor: String
  coverBlockId: ID
  fullscreen: Boolean
  parentBlockId: ID
  themeMode: ThemeMode
  themeName: ThemeName
}

"""DateTime custom scalar"""
scalar DateTime

enum GridAlignItems {
  baseline
  center
  flexEnd
  flexStart
}

type GridContainerBlock implements Block {
  alignItems: GridAlignItems!
  direction: GridDirection!
  id: ID!
  justifyContent: GridJustifyContent!
  parentBlockId: ID
  spacing: Int!
}

enum GridDirection {
  column
  columnReverse
  row
  rowReverse
}

type GridItemBlock implements Block {
  id: ID!
  lg: Int!
  parentBlockId: ID
  sm: Int!
  xl: Int!
}

enum GridJustifyContent {
  center
  flexEnd
  flexStart
}

type Icon {
  color: IconColor
  name: IconName!
  size: IconSize
}

enum IconColor {
  action
  disabled
  error
  inherit
  primary
  secondary
}

"""IconName is equivalent to the icons found in @mui/icons-material"""
enum IconName {
  ArrowForwardRounded
  BeenhereRounded
  ChatBubbleOutlineRounded
  CheckCircleRounded
  ChevronRightRounded
  ContactSupportRounded
  FormatQuoteRounded
  LiveTvRounded
  LockOpenRounded
  MenuBookRounded
  PlayArrowRounded
  RadioButtonUncheckedRounded
  SendRounded
  SubscriptionsRounded
  TranslateRounded
}

enum IconSize {
  inherit
  lg
  md
  sm
  xl
}

enum IdType {
  databaseId
  slug
}

type ImageBlock implements Block {
  alt: String!

  """
  blurhash is a compact representation of a placeholder for an image.
  Find a frontend implementation at https://github.com/woltapp/blurhash
  """
  blurhash: String!
  height: Int!
  id: ID!
  parentBlockId: ID
  src: String!
  width: Int!
}

input ImageBlockCreateInput {
  alt: String!

  """
  ID should be unique Response UUID (Provided for optimistic mutation result matching)
  """
  id: ID
  journeyId: ID!
  parentBlockId: ID
  src: String!
}

input ImageBlockUpdateInput {
  alt: String
  journeyId: ID
  parentBlockId: ID
  src: String
}

scalar join__FieldSet

enum join__Graph {
  JOURNEYS @join__graph(name: "journeys" url: "http://127.0.0.1:4001/graphql")
  USERS @join__graph(name: "users" url: "http://127.0.0.1:4002/graphql")
}

type Journey
  @join__owner(graph: JOURNEYS)
  @join__type(graph: JOURNEYS, key: "id")
{
  blocks: [Block!] @join__field(graph: JOURNEYS)
  createdAt: DateTime! @join__field(graph: JOURNEYS)
  description: String @join__field(graph: JOURNEYS)
  id: ID! @join__field(graph: JOURNEYS)
  locale: String! @join__field(graph: JOURNEYS)
  primaryImageBlock: ImageBlock @join__field(graph: JOURNEYS)
  publishedAt: DateTime @join__field(graph: JOURNEYS)
  slug: String! @join__field(graph: JOURNEYS)
  status: JourneyStatus! @join__field(graph: JOURNEYS)
  themeMode: ThemeMode! @join__field(graph: JOURNEYS)
  themeName: ThemeName! @join__field(graph: JOURNEYS)
  title: String! @join__field(graph: JOURNEYS)
  userJourneys: [UserJourney!] @join__field(graph: JOURNEYS)
}

input JourneyCreateInput {
  description: String

  """
  ID should be unique Response UUID
  (Provided for optimistic mutation result matching)
  """
  id: ID
  locale: String

  """
  Slug should be unique amongst all journeys
  (server will throw BAD_USER_INPUT error if not)
  """
  slug: String!
  themeMode: ThemeMode
  themeName: ThemeName
  title: String!
}

enum JourneyStatus {
  draft
  published
}

input JourneyUpdateInput {
  description: String
  locale: String
  primaryImageBlockId: ID
  slug: String
  themeMode: ThemeMode
  themeName: ThemeName
  title: String
}

type LinkAction implements Action {
  gtmEventName: String
  target: String
  url: String!
}

type Mutation {
  cardBlockCreate(input: CardBlockCreateInput!): CardBlock! @join__field(graph: JOURNEYS)
  cardBlockUpdate(id: ID!, input: CardBlockUpdateInput!): CardBlock! @join__field(graph: JOURNEYS)
  imageBlockCreate(input: ImageBlockCreateInput!): ImageBlock! @join__field(graph: JOURNEYS)
  imageBlockUpdate(id: ID!, input: ImageBlockUpdateInput!): ImageBlock! @join__field(graph: JOURNEYS)
  journeyCreate(input: JourneyCreateInput!): Journey! @join__field(graph: JOURNEYS)
  journeyPublish(id: ID!): Journey @join__field(graph: JOURNEYS)
  journeyUpdate(id: ID!, input: JourneyUpdateInput!): Journey! @join__field(graph: JOURNEYS)
  radioQuestionResponseCreate(input: RadioQuestionResponseCreateInput!): RadioQuestionResponse! @join__field(graph: JOURNEYS)
  signUpResponseCreate(input: SignUpResponseCreateInput!): SignUpResponse! @join__field(graph: JOURNEYS)
  stepBlockCreate(input: StepBlockCreateInput!): StepBlock! @join__field(graph: JOURNEYS)
  stepBlockUpdate(id: ID!, input: StepBlockUpdateInput!): StepBlock! @join__field(graph: JOURNEYS)
  userJourneyApprove(id: ID!): UserJourney! @join__field(graph: JOURNEYS)
  userJourneyPromote(id: ID!): UserJourney! @join__field(graph: JOURNEYS)
  userJourneyRemove(id: ID!): UserJourney! @join__field(graph: JOURNEYS)
  userJourneyRequest(journeyId: ID!): UserJourney! @join__field(graph: JOURNEYS)
  videoBlockCreate(input: VideoBlockCreateInput!): VideoBlock! @join__field(graph: JOURNEYS)
  videoBlockUpdate(id: ID!, input: VideoBlockUpdateInput!): VideoBlock! @join__field(graph: JOURNEYS)
  videoResponseCreate(input: VideoResponseCreateInput!): VideoResponse! @join__field(graph: JOURNEYS)
}

"""
NavigateAction is an Action that navigates to the nextBlockId field set on the
closest ancestor StepBlock.
"""
type NavigateAction implements Action {
  gtmEventName: String
}

type NavigateToBlockAction implements Action {
  blockId: String!
  gtmEventName: String
}

type NavigateToJourneyAction implements Action {
  gtmEventName: String
  journey: Journey
  journeyId: String!
}

type Query {
  journey(id: ID!, idType: IdType): Journey @join__field(graph: JOURNEYS)
  journeys(status: JourneyStatus): [Journey!]! @join__field(graph: JOURNEYS)
  me: User @join__field(graph: USERS)
}

type RadioOptionBlock implements Block {
  action: Action
  id: ID!
  label: String!
  parentBlockId: ID
}

type RadioQuestionBlock implements Block {
  description: String
  id: ID!
  label: String!
  parentBlockId: ID
}

type RadioQuestionResponse implements Response {
  block: RadioQuestionBlock
  id: ID!
  radioOptionBlockId: ID!
  userId: ID!
}

input RadioQuestionResponseCreateInput {
  blockId: ID!

  """
  ID should be unique Response UUID (Provided for optimistic mutation result matching)
  """
  id: ID
  radioOptionBlockId: ID!
}

interface Response {
  id: ID!
  userId: ID!
}

type SignUpBlock implements Block {
  action: Action
  id: ID!
  parentBlockId: ID
  submitIcon: Icon
  submitLabel: String
}

type SignUpResponse implements Response {
  block: SignUpBlock
  email: String!
  id: ID!
  name: String!
  userId: ID!
}

input SignUpResponseCreateInput {
  blockId: ID!
  email: String!

  """
  ID should be unique Response UUID (Provided for optimistic mutation result matching)
  """
  id: ID
  name: String!
}

type StepBlock implements Block {
  id: ID!

  """
  locked will be set to true if the user should not be able to manually
  advance to the next step.
  """
  locked: Boolean!

  """
  nextBlockId contains the preferred block to navigate to when a
  NavigateAction occurs or if the user manually tries to advance to the next
  step. If no nextBlockId is set it can be assumed that this step represents
  the end of the current journey.
  """
  nextBlockId: ID
  parentBlockId: ID
}

input StepBlockCreateInput {
  id: ID
  journeyId: ID!
  locked: Boolean
  nextBlockId: ID
  parentBlockId: ID
}

input StepBlockUpdateInput {
  locked: Boolean
  nextBlockId: ID
  parentBlockId: ID
}

enum ThemeMode {
  dark
  light
}

enum ThemeName {
  base
}

enum TypographyAlign {
  center
  left
  right
}

type TypographyBlock implements Block {
  align: TypographyAlign
  color: TypographyColor
  content: String!
  id: ID!
  parentBlockId: ID
  variant: TypographyVariant
}

enum TypographyColor {
  error
  primary
  secondary
}

enum TypographyVariant {
  body1
  body2
  caption
  h1
  h2
  h3
  h4
  h5
  h6
  overline
  subtitle1
  subtitle2
}

type User
  @join__owner(graph: USERS)
  @join__type(graph: USERS, key: "id")
{
  email: String! @join__field(graph: USERS)
  firstName: String! @join__field(graph: USERS)
  id: ID! @join__field(graph: USERS)
  imageUrl: String @join__field(graph: USERS)
  lastName: String @join__field(graph: USERS)
}

type UserJourney
  @join__owner(graph: JOURNEYS)
  @join__type(graph: JOURNEYS, key: "id")
  @join__type(graph: USERS, key: "id")
{
  id: ID! @join__field(graph: JOURNEYS)
  journey: Journey @join__field(graph: JOURNEYS)
  journeyId: ID! @join__field(graph: JOURNEYS)
  role: UserJourneyRole! @join__field(graph: JOURNEYS)
  user: User @join__field(graph: USERS)
  userId: ID! @join__field(graph: JOURNEYS)
}

enum UserJourneyRole {
  editor
  inviteRequested
  owner
}

type VideoArclight implements VideoContent {
  languageId: String!
  mediaComponentId: String!
  src: String!
}

type VideoBlock implements Block {
  autoplay: Boolean
  description: String

  """endAt dictates at which point of time the video should end"""
  endAt: Int
  id: ID!
  muted: Boolean
  parentBlockId: ID

  """
  posterBlockId is present if a child block should be used as a poster.
  This child block should not be rendered normally, instead it should be used
  as the video poster. PosterBlock should be of type ImageBlock.
  """
  posterBlockId: ID

  """startAt dictates at which point of time the video should start playing"""
  startAt: Int
  title: String!
  videoContent: VideoContent!
}

input VideoBlockCreateInput {
  autoplay: Boolean
  description: String

  """endAt dictates at which point of time the video should end"""
  endAt: Int
  id: ID
  journeyId: ID!
  muted: Boolean
  parentBlockId: ID

  """
  posterBlockId is present if a child block should be used as a poster.
  This child block should not be rendered normally, instead it should be used
  as the video poster. PosterBlock should be of type ImageBlock.
  """
  posterBlockId: ID

  """startAt dictates at which point of time the video should start playing"""
  startAt: Int
  title: String!
  videoContent: VideoContentInput!
}

input VideoBlockUpdateInput {
  autoplay: Boolean
  description: String

  """endAt dictates at which point of time the video should end"""
  endAt: Int
  muted: Boolean
  parentBlockId: ID

  """
  posterBlockId is present if a child block should be used as a poster.
  This child block should not be rendered normally, instead it should be used
  as the video poster. PosterBlock should be of type ImageBlock.
  """
  posterBlockId: ID

  """startAt dictates at which point of time the video should start playing"""
  startAt: Int
  title: String
  videoContent: VideoContentInput
}

interface VideoContent {
  src: String!
}

input VideoContentInput {
  languageId: String
  mediaComponentId: String
  src: String
}

type VideoGeneric implements VideoContent {
  src: String!
}

type VideoResponse implements Response {
  block: VideoBlock
  id: ID!
  position: Int
  state: VideoResponseStateEnum!
  userId: ID!
}

input VideoResponseCreateInput {
  blockId: ID!

  """
  ID should be unique Response UUID (Provided for optimistic mutation result matching)
  """
  id: ID
  position: Float
  state: VideoResponseStateEnum!
}

enum VideoResponseStateEnum {
  FINISHED
  PAUSED
  PLAYING
}

"""
VideoTriggerBlock is a block that indicates the video to navigate
to the next block at the designated time.
"""
type VideoTriggerBlock implements Block {
  action: Action
  id: ID!
  parentBlockId: ID

  """
  triggerStart sets the time as to when a video navigates to the next block,
  this is the number of seconds since the start of the video
  """
  triggerStart: Int!
}
