# Team Invite Email Missing Sender Name Bug Fix

## Problem Description

Users were receiving team invitation emails where the sender's first name was missing from the email content, resulting in malformed header text like `" invites you to the workspace:"` instead of `"John invites you to the workspace:"`.

### Symptoms

- **Gmail Authenticated Accounts**: Working correctly - sender name appears
- **Email/Password Authenticated Accounts**: Bug present - sender name missing
- **Affected Templates**: `TeamInvite.tsx`, `TeamInviteNoAccount.tsx`, and `TeamInviteAccepted.tsx`
- **Email Patterns**:
  - Team invites: `${sender.firstName} invites you to the workspace:`
  - Invite accepted: `${sender.firstName} accepted your invite to:` and preview text `${sender.firstName} has been added to your team`

## Root Cause Analysis

The issue originates in the Firebase JWT payload processing logic in `libs/nest/common/src/lib/firebaseClient/firebaseClient.ts`:

```typescript
firstName: data.name?.split(' ').slice(0, -1).join(' ') ?? '',
```

### Authentication Method Differences

**Gmail Authentication:**

- Google automatically populates the `name` field in JWT payloads with the user's Google profile name
- Results in proper `firstName` extraction

**Email/Password Authentication:**

- During registration, `displayName` is set using Firebase's `updateProfile()`
- However, the `displayName` doesn't always reflect consistently in JWT payload's `name` field
- When `name` is `null/undefined`, `firstName` becomes an empty string `''`

### Flow Analysis

1. **Frontend**:
   - `UserTeamInviteForm` triggers `userTeamInviteCreate` mutation
   - Team invite acceptance triggers `teamInviteAccepted` email
2. **Resolver**: Extracts sender from JWT via `@CurrentUser()` decorator
3. **Service**: Creates email job with sender data (missing `firstName` for email/password accounts)
4. **Worker**: Processes job and renders email template with empty sender name
5. **Email**: Recipients see malformed content:
   - Team invites: `" invites you to the workspace:"`
   - Invite accepted: `" accepted your invite to:"` and `" has been added to your team"`

## Solution Approach

Instead of relying on potentially incomplete JWT payload data, fetch complete sender information from the database where user data is properly stored during the email processing phase.

### Key Strategy

- **Database as Source of Truth**: Query user database for complete sender data
- **Graceful Fallback**: Use JWT data if database query fails
- **Email-based Fallback**: Extract firstName from email address when all other sources fail
- **Minimal Breaking Changes**: Leverage existing GraphQL infrastructure
- **Maintain Compatibility**: No changes to email templates needed

## Implementation Details

### Changes Made

#### 1. Enhanced Job Interface

**File**: `apis/api-journeys-modern/src/workers/email/service/prisma.types.ts`

```typescript
export interface TeamInviteJob {
  team: Team
  email: string
  sender: OmittedUser
  senderId: string // Add sender ID to fetch complete user data
}

export interface TeamInviteAccepted {
  team: TeamWithUserTeam
  sender: OmittedUser
  senderId: string // Add sender ID to fetch complete user data
}
```

**Purpose**: Include sender ID in job data to enable database lookup during email processing.

#### 2. Updated Email Service

**File**: `apis/api-journeys/src/app/modules/userTeamInvite/userTeamInvite.service.ts`

```typescript
async sendTeamInviteEmail(
  team: Team,
  email: string,
  sender: Omit<User, 'id' | 'emailVerified'>,
  senderId: string // Add new parameter
): Promise<void> {
  await this.emailQueue.add(
    'team-invite',
    {
      team,
      email,
      sender,
      senderId // Include in job data
    },
    {
      removeOnComplete: true,
      removeOnFail: {
        age: 24 * 3600 // keep up to 24 hours
      }
    }
  )
}
```

**Purpose**: Accept and pass sender ID to email worker for database lookup.

#### 3. Updated Resolver

**File**: `apis/api-journeys/src/app/modules/userTeamInvite/userTeamInvite.resolver.ts`

```typescript
await this.userTeamInviteService.sendTeamInviteEmail(
  userTeamInvite.team as unknown as Team,
  input.email,
  omit(sender, ['id', 'emailVerified']),
  sender.id // Pass actual sender ID instead of omitting it
)
```

**Purpose**: Provide sender ID to service while maintaining backward compatibility.

#### 4. Enhanced Email Workers

**File**: `apis/api-journeys-modern/src/workers/email/service/service.ts`

```typescript
export async function teamInviteEmail(job: Job<TeamInviteJob>): Promise<void> {
  const url = `${process.env.JOURNEYS_ADMIN_URL ?? ''}/?activeTeam=${job.data.team.id}`

  // check recipient preferences
  const preferences = await prisma.journeysEmailPreference.findFirst({
    where: {
      email: job.data.email
    }
  })

  if (preferences?.accountNotifications === false || preferences?.unsubscribeAll === true) return

  // Fetch complete sender data from database using senderId for accurate sender information
  let enhancedSender = job.data.sender // fallback to job data sender
  try {
    if (job.data.senderId != null) {
      const { data: senderData } = await apollo.query({
        query: GET_USER,
        variables: { userId: job.data.senderId }
      })
      if (senderData.user != null) {
        // Use database data with complete information, omitting id and emailVerified to match expected type
        enhancedSender = {
          firstName: senderData.user.firstName,
          lastName: senderData.user.lastName,
          email: senderData.user.email,
          imageUrl: senderData.user.imageUrl
        }
      }
    }
  } catch (error) {
    console.warn('Failed to fetch sender data from database, using fallback:', error)
    // enhancedSender already set to fallback value
  }

  // Ultimate fallback: Extract firstName from email if no firstName available
  if (!enhancedSender.firstName || enhancedSender.firstName.trim() === '') {
    const emailLocalPart = enhancedSender.email?.split('@')[0] || 'User'
    enhancedSender.firstName = emailLocalPart
    console.info(`Using email-based firstName fallback: ${emailLocalPart} from ${enhancedSender.email}`)
  }

  const { data } = await apollo.query({
    query: GET_USER_BY_EMAIL,
    variables: { email: job.data.email }
  })

  // Use the reliable sender data in both email templates
  if (data.userByEmail == null) {
    const html = await render(
      TeamInviteNoAccountEmail({
        teamName: job.data.team.title,
        inviteLink: url,
        sender: enhancedSender, // Use enhanced sender data with email fallback
        recipientEmail: job.data.email
      })
    )
    // ... rest of no-account flow
  } else {
    const html = await render(
      TeamInviteEmail({
        teamName: job.data.team.title,
        recipient: data.userByEmail,
        inviteLink: url,
        sender: enhancedSender // Use enhanced sender data with email fallback
      })
    )
    // ... rest of existing user flow
  }
}

export async function teamInviteAcceptedEmail(job: Job<TeamInviteAccepted>): Promise<void> {
  const url = `${process.env.JOURNEYS_ADMIN_URL ?? ''}/?activeTeam=${job.data.team.id}`

  // Find team manager (recipient of the acceptance notification)
  const recipient = job.data.team.userTeams?.find((userTeam) => userTeam.role === UserTeamRole.manager)

  if (recipient?.user == null) return

  // check recipient preferences
  const preferences = await prisma.journeysEmailPreference.findFirst({
    where: {
      email: recipient.user.email
    }
  })

  if (preferences?.accountNotifications === false || preferences?.unsubscribeAll === true) return

  // Fetch complete sender data from database using senderId
  let enhancedSender = job.data.sender // fallback to job data sender
  try {
    if (job.data.senderId != null) {
      const { data: senderData } = await apollo.query({
        query: GET_USER,
        variables: { userId: job.data.senderId }
      })
      if (senderData.user != null) {
        enhancedSender = {
          firstName: senderData.user.firstName,
          lastName: senderData.user.lastName,
          email: senderData.user.email,
          imageUrl: senderData.user.imageUrl
        }
      }
    }
  } catch (error) {
    console.warn('Failed to fetch sender data from database, using fallback:', error)
  }

  // Ultimate fallback: Extract firstName from email if no firstName available
  if (!enhancedSender.firstName || enhancedSender.firstName.trim() === '') {
    const emailLocalPart = enhancedSender.email?.split('@')[0] || 'User'
    enhancedSender.firstName = emailLocalPart
    console.info(`Using email-based firstName fallback: ${emailLocalPart} from ${enhancedSender.email}`)
  }

  const recipientUser = {
    firstName: recipient.user.firstName,
    lastName: recipient.user.lastName ?? undefined,
    email: recipient.user.email,
    imageUrl: recipient.user.imageUrl ?? undefined
  }

  const html = await render(
    TeamInviteAcceptedEmail({
      teamName: job.data.team.title,
      inviteLink: url,
      sender: enhancedSender, // Use enhanced sender data
      recipient: recipientUser
    })
  )

  const text = await render(
    TeamInviteAcceptedEmail({
      teamName: job.data.team.title,
      inviteLink: url,
      sender: enhancedSender, // Use enhanced sender data
      recipient: recipientUser
    }),
    {
      plainText: true
    }
  )

  await sendEmail({
    to: recipient.user.email,
    subject: `${enhancedSender.firstName ?? 'A new member'} has been added to your team`,
    text,
    html
  })
}
```

**Purpose**: Fetch reliable sender data from database with graceful fallback logic for both team invite and team invite accepted emails.

## Technical Benefits

### 1. Reliability

- **Database as Source of Truth**: User data in database is properly validated and stored
- **Consistent Data**: Same data source used regardless of authentication method
- **Fallback Protection**: Graceful degradation if database query fails

### 2. Maintainability

- **Leverages Existing Infrastructure**: Uses existing GraphQL queries and Apollo client
- **No Template Changes**: Email templates remain unchanged
- **Backward Compatible**: Existing job processing continues to work

### 3. Performance

- **Single Additional Query**: Only one extra database lookup per email job
- **Async Processing**: Database lookup happens during background job processing
- **Cacheable**: GraphQL queries can be cached if needed

## Testing Strategy

### Unit Tests

```typescript
describe('teamInviteEmail', () => {
  it('should use database sender data when available', async () => {
    // Mock database response with complete user data
    // Verify email template receives proper firstName
  })

  it('should fallback to job data when database query fails', async () => {
    // Mock database failure
    // Verify fallback logic works
  })

  it('should handle missing firstName with email-based fallback', async () => {
    // Mock scenario where both database and job data have empty firstName
    // Verify email address is used to extract firstName
    // Example: "testuser123@hotmail.com" → firstName: "testuser123"
  })

  it('should extract firstName from various email formats', async () => {
    // Test email patterns: john.doe@example.com → "john.doe"
    // Test simple emails: user123@domain.com → "user123"
    // Test edge cases: a@b.com → "a"
  })
})

describe('teamInviteAcceptedEmail', () => {
  it('should use enhanced sender data in template content', async () => {
    // Mock database response with complete user data
    // Verify both preview text and header text receive proper firstName
    // Example: "${sender.firstName} has been added to your team"
    // Example: "${sender.firstName} accepted your invite to:"
  })

  it('should fallback to job data when database query fails', async () => {
    // Mock database failure
    // Verify fallback logic works for accepted emails
  })

  it('should use email-based firstName fallback in template content', async () => {
    // Mock scenario where firstName is empty
    // Verify email address is used in both preview and header text
    // Example: "testuser123@company.com" → "testuser123 has been added to your team"
  })

  it('should maintain existing subject line fallback', async () => {
    // Verify subject line continues to use 'A new member' fallback
    // This should not be affected by database lookup since it already has fallback
  })
})
```

### Integration Tests

1. **Email/Password Account Flow**:

   - Create account with email/password
   - Send team invitation
   - Accept team invitation from another email/password account
   - Verify sender name appears correctly in both invite and acceptance emails

2. **Gmail Account Flow**:

   - Ensure existing Gmail authentication continues working
   - Verify no regression in sender name display for both email types

3. **Cross-Authentication Testing**:

   - Gmail user sends team invite, email/password user accepts → verify both emails
   - Email/password user sends invite, Gmail user accepts → verify both emails

4. **Edge Cases**:
   - Very long names in both email templates
   - Special characters in names
   - Empty/null names with email-based fallback
   - Database connectivity issues
   - Email-based firstName extraction from various email formats

### Manual Testing Checklist

- [ ] Create email/password account with full name
- [ ] Send team invitation from this account
- [ ] Verify email shows: "FirstName invites you to the workspace:"
- [ ] Accept team invitation and verify manager receives: "FirstName accepted your invite to:"
- [ ] Verify acceptance email preview shows: "FirstName has been added to your team"
- [ ] Test with Gmail account (regression check for both email types)
- [ ] Test with edge case names (special chars, very long) in both templates
- [ ] Test with empty firstName scenario (verify email-based fallback in both emails)
- [ ] Test various email formats: john.doe@domain.com, user123@example.org
- [ ] Monitor email worker logs for fallback usage and any errors
- [ ] Verify existing subject line fallback still works for acceptance emails

## Monitoring and Observability

### Recommended Logging

```typescript
// In email worker
try {
  // Database lookup attempt
  const { data: senderData } = await apollo.query({
    query: GET_USER,
    variables: { userId: job.data.senderId }
  })
  if (senderData.user != null) {
    console.info(`Successfully fetched sender data for userId: ${job.data.senderId}, firstName: ${senderData.user.firstName}`)
  }
} catch (error) {
  console.warn('Failed to fetch sender data from database, using fallback:', error)
}

// Email-based firstName fallback logging
if (!enhancedSender.firstName || enhancedSender.firstName.trim() === '') {
  const emailLocalPart = enhancedSender.email?.split('@')[0] || 'User'
  enhancedSender.firstName = emailLocalPart
  console.info(`Using email-based firstName fallback: ${emailLocalPart} from ${enhancedSender.email}`)
}
```

### Metrics to Track

- **Database Query Success Rate**: Monitor GET_USER query success/failure rates
- **Fallback Usage**: Track how often fallback sender data is used
- **Email-based Fallback Usage**: Monitor frequency of firstName extraction from email addresses
- **Email Processing Time**: Ensure additional query doesn't significantly impact processing time
- **firstName Quality**: Track percentage of emails sent with proper firstName vs email-based fallback

## Alternative Solutions Considered

### Option 1: Fix JWT Payload Processing

**Approach**: Modify `libs/nest/common/src/lib/firebaseClient/firebaseClient.ts` to call Firebase Admin SDK when `name` is missing.

**Pros**:

- Fixes root cause
- No changes to email system

**Cons**:

- Adds latency to all JWT processing
- Potential Firebase API rate limits
- Affects all API endpoints

### Option 2: Enhanced Registration Flow

**Approach**: Ensure `displayName` is properly reflected in JWT during email/password registration.

**Pros**:

- Prevents issue at source
- No additional database queries

**Cons**:

- Doesn't fix existing users
- Requires frontend changes
- Firebase behavior dependency

### Why Database Fallback Was Chosen

- **Immediate Fix**: Resolves issue for all existing users
- **Reliable**: Database is authoritative source for user data
- **Scoped Impact**: Changes isolated to email system
- **Graceful**: Fallback logic prevents total failure

## Deployment Notes

### Prerequisites

- No database migrations required
- No environment variable changes needed
- Existing GraphQL infrastructure must be operational

### Deployment Order

1. Deploy `api-journeys-modern` worker changes
2. Deploy `api-journeys` service changes
3. Verify email processing continues normally
4. Monitor for any errors in worker logs

### Rollback Plan

If issues arise, changes can be reverted in reverse order:

1. Revert `api-journeys` resolver/service changes
2. Revert `api-journeys-modern` worker changes
3. Email system will fall back to original JWT-based sender data

## Future Improvements

### Potential Optimizations

1. **Caching**: Cache user data lookups to reduce database load
2. **Batch Processing**: If multiple emails for same sender, reuse lookup
3. **Proactive Sync**: Ensure JWT payload stays in sync with database

### Related Issues to Consider

- Apply similar fix to other email types that use sender data
- Consider audit of all places where user data from JWT might be incomplete
- Evaluate if other authentication providers have similar issues

## Conclusion

This fix provides a robust solution to the missing sender name issue in team-related emails by using the database as the authoritative source for user information during email processing. The implementation covers both team invitation emails and team invitation acceptance notifications, ensuring complete coverage of the team collaboration email flow.

The solution maintains backward compatibility while ensuring reliable sender name display regardless of authentication method. It includes comprehensive fallback mechanisms (database → job data → email-based extraction) and is production-ready.

This implementation can serve as a pattern for similar user data reliability issues throughout the email system and establishes a solid foundation for consistent sender information across all team-related communications.
